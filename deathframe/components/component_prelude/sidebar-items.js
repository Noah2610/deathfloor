initSidebarItems({"derive":[["Component","Custom derive macro for the `Component` trait."]],"enum":[["Axis","Just a plain `Axis` enum with `X` and `Y` variants."]],"struct":[["AxisIter","An iterator over both axes."],["DenseVecStorage","Dense vector storage. Has a redirection 2-way table between entities and components, allowing to leave no gaps within the data."],["Entity","`Entity` type, as seen by the user."],["HashMapStorage","`HashMap`-based storage. Best suited for rare components."],["NullStorage","A null storage type, used for cases where the component doesn't contain any data and instead works as a simple flag."],["Rect","A `Rect` is simply an area. It has positions bounding sides (top, bottom, left, right)."],["RectBuilder","Builder for `Rect`."],["Storage","A wrapper around the masked storage and the generations vector. Can be used for safe lookup of components, insertions and removes. This is what `World::read/write` fetches for the user."],["VecStorage","Vector storage. Uses a simple `Vec`. Supposed to have maximum performance for the components mostly present in entities."]],"trait":[["ByAxis","Anything implementing the `ByAxis` trait, returns an item through the `by_axis` method, by passing an `&Axis`. This is useful when you have a tuple or similar with two items, where each item represents an axis. You can get the specifc item by indexing with an `Axis`. Here's an example, and what code this would save: ``` use deathframe_core::geo::prelude::{Axis, ByAxis};"],["Component","Abstract component type. Doesn't have to be Copy or even Clone."]],"type":[["Point",""],["Vector",""]]});